{"version":3,"sources":["../../../src/datetime-mask/createAutoCorrectedDateTimePipe.ts"],"names":[],"mappings":"AAAA,MAAM,CAAC,OAAO,0CAA0C,UAAkC;IAAlC,2BAAA,EAAA,kCAAkC;IACxF,MAAM,CAAC,UAAC,cAAmB;QACzB,IAAM,mBAAmB,GAAU,EAAE,CAAC;QACtC,IAAM,eAAe,GAAQ,UAAU,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;QAC5D,IAAM,QAAQ,GAAQ,EAAE,IAAI,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC;QACnG,IAAM,QAAQ,GAAQ,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC;QAC1F,IAAM,iBAAiB,GAAQ,cAAc,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;QAGxD,eAAe,CAAC,OAAO,CAAC,UAAC,MAAW;YAClC,IAAM,QAAQ,GAAG,UAAU,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;YAC5C,IAAM,aAAa,GAAG,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAE,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;YAE7E,EAAE,CAAC,CAAC,QAAQ,CAAC,iBAAiB,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,GAAG,aAAa,CAAC,CAAC,CAAC;gBAC9D,iBAAiB,CAAC,QAAQ,GAAG,CAAC,CAAC,GAAG,iBAAiB,CAAC,QAAQ,CAAC,CAAC;gBAC9D,iBAAiB,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;gBAChC,mBAAmB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACrC,CAAC;QACH,CAAC,CAAC,CAAC;QAGH,IAAM,SAAS,GAAG,eAAe,CAAC,IAAI,CAAC,UAAC,MAAW;YACjD,IAAM,QAAQ,GAAQ,UAAU,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;YACjD,IAAM,MAAM,GAAQ,MAAM,CAAC,MAAM,CAAC;YAClC,IAAM,SAAS,GAAQ,cAAc,CAAC,MAAM,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;YAClF,IAAM,KAAK,GAAQ,QAAQ,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;YAE3C,MAAM,CAAC,KAAK,GAAG,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,MAAM,IAAI,KAAK,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;QAC/F,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;YACd,MAAM,CAAC,KAAK,CAAC;QACf,CAAC;QAED,MAAM,CAAC;YACL,KAAK,EAAE,iBAAiB,CAAC,IAAI,CAAC,EAAE,CAAC;YACjC,mBAAmB,qBAAA;SACpB,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC","file":"createAutoCorrectedDateTimePipe.js","sourceRoot":"","sourcesContent":["export default function createAutoCorrectedDateTimePipe(dateFormat = 'DD-MM-yyyy HH:mm:ss') {\r\n  return (conformedValue: any) => {\r\n    const indexesOfPipedChars: any[] = [];\r\n    const dateFormatArray: any = dateFormat.split(/[^DMYHms]+/);\r\n    const maxValue: any = { 'DD': 31, 'MM': 12, 'YY': 99, 'YYYY': 9999, 'HH': 23, 'mm': 59, 'ss': 59 };\r\n    const minValue: any = { 'DD': 1, 'MM': 1, 'YY': 0, 'YYYY': 1, 'HH': 0, 'mm': 0, 'ss': 0 };\r\n    const conformedValueArr: any = conformedValue.split('');\r\n\r\n    // Check first digit\r\n    dateFormatArray.forEach((format: any) => {\r\n      const position = dateFormat.indexOf(format);\r\n      const maxFirstDigit = parseInt(maxValue[format].toString().substr(0, 1), 10);\r\n\r\n      if (parseInt(conformedValueArr[position], 10) > maxFirstDigit) {\r\n        conformedValueArr[position + 1] = conformedValueArr[position];\r\n        conformedValueArr[position] = 0;\r\n        indexesOfPipedChars.push(position);\r\n      }\r\n    });\r\n\r\n    // Check for invalid date\r\n    const isInvalid = dateFormatArray.some((format: any) => {\r\n      const position: any = dateFormat.indexOf(format);\r\n      const length: any = format.length;\r\n      const textValue: any = conformedValue.substr(position, length).replace(/\\D/g, '');\r\n      const value: any = parseInt(textValue, 10);\r\n\r\n      return value > maxValue[format] || (textValue.length === length && value < minValue[format]);\r\n    });\r\n\r\n    if (isInvalid) {\r\n      return false;\r\n    }\r\n\r\n    return {\r\n      value: conformedValueArr.join(''),\r\n      indexesOfPipedChars\r\n    };\r\n  };\r\n}\r\n"]}